<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Building SQL Expressions with Sequel | Janko Marohnić</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" href="/favicon.ico?v=1" sizes="any">
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Building SQL Expressions with Sequel" />
<meta name="author" content="Janko Marohnić" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I’ve recently started working on a new project which uses Sequel, and it reminded me how much I love it. For those who don’t know, Sequel is a superb alternative to Active Record. I wrote a gentle introduction to Sequel a while back." />
<meta property="og:description" content="I’ve recently started working on a new project which uses Sequel, and it reminded me how much I love it. For those who don’t know, Sequel is a superb alternative to Active Record. I wrote a gentle introduction to Sequel a while back." />
<link rel="canonical" href="https://bits.theorem.co/building-sql-expressions-with-sequel/" />
<meta property="og:url" content="https://bits.theorem.co/building-sql-expressions-with-sequel/" />
<meta property="og:site_name" content="Janko Marohnić" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-11-21T00:00:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Building SQL Expressions with Sequel" />
<meta name="twitter:site" content="@jankomarohnic" />
<meta name="twitter:creator" content="@jankomarohnic" />
<meta property="article:publisher" content="https://www.facebook.com/janko.marohnic/" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"https://bits.theorem.co/building-sql-expressions-with-sequel/"},"author":{"@type":"Person","name":"Janko Marohnić"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://janko.io/images/logo.png"},"name":"Janko Marohnić"},"@type":"BlogPosting","description":"I’ve recently started working on a new project which uses Sequel, and it reminded me how much I love it. For those who don’t know, Sequel is a superb alternative to Active Record. I wrote a gentle introduction to Sequel a while back.","url":"https://bits.theorem.co/building-sql-expressions-with-sequel/","headline":"Building SQL Expressions with Sequel","dateModified":"2018-11-21T00:00:00+01:00","datePublished":"2018-11-21T00:00:00+01:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link type="application/atom+xml" rel="alternate" href="https://janko.io/feed.xml" title="Janko Marohnić" />
    <link rel="stylesheet" href="/css/bundle.css">
    
      <script src="https://cdn.usefathom.com/script.js" data-site="EKJCVCTX" defer></script>
    
    <script>
      function updateTheme() {
        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
          document.documentElement.classList.add('dark')
        } else {
          document.documentElement.classList.remove('dark')
        }
      }
      updateTheme()
    </script>
  </head>

  <body class="text-xl text-slate-700 dark:bg-slate-900 dark:text-slate-400 min-h-screen flex flex-col">
    <header class="py-3 px-4 bg-gray-100 border-b dark:bg-slate-800/70 dark:border-slate-700">
      <div class="max-w-screen-sm md:max-w-screen-md mx-auto flex items-center">
        <div class="flex-1">
          <a class="text-lg xs:text-xl sm:text-2xl md:text-3xl font-semibold tracking-wide text-pink-700/80 hover:text-pink-800 dark:text-pink-500 dark:hover:text-pink-400 transition" href="/">
            Janko Marohnić
          </a>
        </div>

        <a class="flex items-center space-x-2 justify-self-center" href="/">
          <svg class="h-7 w-7 rounded lg:h-10 lg:w-10 lg:rounded-lg" role="img" aria-labelledby="logo-title" viewBox="0 0 64 64">
            <title id="logo-title">logo</title>
            <clipPath id="topLeft"><path d="M64,0.025l-64,64l0,-64l64,0Z"></path></clipPath>
            <clipPath id="bottomRight"><path d="M0,64l64,-64l0,64l-64,0Z"></path></clipPath>
            <g clip-path="url(#topLeft)"><rect class="fill-current text-pink-500" x="0.025" y="0.025" width="64" height="64"></rect><path class="fill-current text-white" d="M31.989,22.518c-0.031,-4.597 -0.902,-8.134 -2.612,-10.613c-1.71,-2.478 -4.165,-3.717 -7.365,-3.717c-3.2,0 -5.655,1.251 -7.365,3.753c-1.71,2.502 -2.565,6.114 -2.565,10.836l0,6.471c0.063,4.549 0.953,8.043 2.671,10.483c1.718,2.439 4.153,3.659 7.306,3.659c3.185,0 5.636,-1.255 7.354,-3.765c1.717,-2.51 2.576,-6.134 2.576,-10.871l0,-6.236Zm-6.682,7.647c-0.032,2.605 -0.31,4.538 -0.836,5.801c-0.525,1.263 -1.329,1.894 -2.412,1.894c-1.145,0 -1.988,-0.675 -2.529,-2.024c-0.542,-1.349 -0.812,-3.404 -0.812,-6.165l0,-8.541c0.078,-4.942 1.176,-7.413 3.294,-7.413c1.13,0 1.961,0.675 2.494,2.024c0.534,1.349 0.801,3.373 0.801,6.071l0,8.353Z"></path></g><g clip-path="url(#bottomRight)"><rect class="fill-current text-pink-700" x="0.025" y="0.025" width="64" height="64"></rect><path class="fill-current text-white" d="M44.945,55.261l-6.553,0l0,-25.659l-6.392,2.469l0,-5.446l12.253,-5.007l0.692,0l0,33.643Z"></path><
          </svg>
        </a>

        <span class="flex-1 flex space-x-2 justify-end">
          <button type="button" class="theme-reset rounded-full bg-sky-200 dark:bg-sky-900 px-2.5 py-1 text-xs font-medium text-sky-700 dark:text-white shadow-sm dark:hover:bg-sky-800 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-sky-200">Reset to OS</button>

          <button type="button" class="theme-toggle bg-gray-200 relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transitikon-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-pink-700 focus:ring-offset-2 dark:focus:ring-pink-500 dark:focus:ring-offset-slate-900" role="switch" aria-checked="false">
            <span class="sr-only">Use setting</span>
            <span class="theme-toggle-ring translate-x-0 pointer-events-none relative inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out">
              <span class="theme-toggle-light opacity-100 duration-200 ease-in absolute inset-0 flex h-full w-full items-center justify-center transition-opacity" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4kkkkkkk h-4">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-4.773-4.227l-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z" />
                </svg>
              </span>
              <span class="theme-toggle-dark opacity-0 duration-100 ease-out absolute inset-0 flex h-full w-full items-center justify-center transition-opacity" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4 text-pink-500">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z" />
                </svg>
              </span>
            </span>
          </button>
        </span>
      </div>
    </header>

    <div class="flex-1 my-2 sm:my-4 mx-4">
      <main class="max-w-screen-sm md:max-w-screen-md mx-auto">
        <article class="mt-6">
  <time datetime="2018-11-21" class="flex items-center text-slate-400 text-sm md:text-base">
    <span class="h-4 md:h-5 w-0.5 rounded-full bg-slate-200 dark:bg-slate-500"></span>
    <span class="ml-3">November 21, 2018</span>
  </time>

  <h1 class="mt-5 sm:mt-6 text-3xl sm:text-4xl lg:text-5xl font-semibold text-slate-900 tracking-tight dark:text-slate-100">Building SQL Expressions with Sequel</h1>

  <div class="mt-6 sm:mt-8 markdown">
    <p>I’ve recently started working on a new project which uses <a href="https://github.com/jeremyevans/sequel">Sequel</a>, and it reminded me how much I love it. For those who don’t know, Sequel is a superb alternative to Active Record. I wrote a <a href="https://janko.io/ode-to-sequel/">gentle introduction to Sequel</a> a while back.</p>

<p>One of the prettiest parts of Sequel for me is the API for building SQL expressions, so in this article I would like to talk more about that. But before we start with Sequel, I first want to talk a little bit about Active Record.</p>

<h2 id="active-record">Active Record</h2>

<p>In Active Record, equality and inclusion expressions are typically built with simple ruby hashes:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">rating: </span><span class="mi">7</span><span class="p">,</span> <span class="ss">genre: </span><span class="p">[</span><span class="s2">"Adventure"</span><span class="p">,</span> <span class="s2">"Comedy"</span><span class="p">])</span>
<span class="c1"># WHERE movies.rating = 7 AND movies.genre IN ('Adventure', 'Comedy')</span>
</code></pre></div></div>

<p>Negation is also easy with <code class="language-plaintext highlighter-rouge">where.not(...)</code>:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">where</span><span class="p">.</span><span class="nf">not</span><span class="p">(</span><span class="ss">rating: </span><span class="mi">7</span><span class="p">,</span> <span class="ss">genre: </span><span class="p">[</span><span class="s2">"Adventure"</span><span class="p">,</span> <span class="s2">"Comedy"</span><span class="p">])</span>
<span class="c1"># WHERE movies.rating != 7 AND movies.genre NOT IN ('Adventure', 'Comedy')</span>
</code></pre></div></div>

<p>A nested hash can be used to qualify columns with a different table name (useful for joined datasets):</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:rating</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">rating: </span><span class="p">{</span> <span class="ss">imdb: </span><span class="mi">7</span><span class="p">,</span> <span class="ss">netflix: </span><span class="mi">5</span><span class="o">..</span><span class="mi">8</span> <span class="p">})</span>
<span class="c1"># WHERE rating.imdb = 7 AND rating.netflix &gt;= 5 AND rating.netflix &lt;= 8</span>
</code></pre></div></div>

<p>However, as soon as we need something that cannot be expressed by a hash, it’s common to just reach for raw SQL strings:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"year &gt;= ? OR name LIKE ?"</span><span class="p">,</span> <span class="mi">2012</span><span class="p">,</span> <span class="s2">"Summer%"</span><span class="p">)</span>
<span class="c1"># or</span>
<span class="no">Movie</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"year &gt;= :year OR name LIKE :term"</span><span class="p">,</span> <span class="ss">year: </span><span class="mi">2012</span><span class="p">,</span> <span class="ss">term: </span><span class="s2">"Summer%"</span><span class="p">)</span>
</code></pre></div></div>

<p>Personally, I find this less readable than the hash version, because we need to use placeholders for values that need to be escaped, and provide actual values after the SQL string. Using raw SQL strings is also not very consistent, because now you have some expressions built in Ruby and other are provided in raw SQL.</p>

<p>To address these disadvantages, many people have discovered <a href="https://blog.codeship.com/creating-advanced-active-record-db-queries-arel/">Arel</a>, Active Record’s internal query builder. It has an expression builder API that allows us to avoid SQL strings for many types of expressions.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="no">Movie</span><span class="p">.</span><span class="nf">arel_table</span><span class="p">[</span><span class="ss">:rating</span><span class="p">].</span><span class="nf">gteq</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="c1"># SELECT movies.* FROM movies WHERE movies.rating &gt;= 7</span>
</code></pre></div></div>

<p>We can chain method calls to create more complex expressions, and add the <a href="https://github.com/camertron/arel-helpers">arel-helpers</a> gem that aliases <code class="language-plaintext highlighter-rouge">#arel_table</code> to <code class="language-plaintext highlighter-rouge">#[]</code>:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="no">Movie</span><span class="p">[</span><span class="ss">:rating</span><span class="p">].</span><span class="nf">gteq</span><span class="p">(</span><span class="mi">7</span><span class="p">).</span><span class="nf">or</span><span class="p">(</span><span class="no">Movie</span><span class="p">[</span><span class="ss">:director</span><span class="p">].</span><span class="nf">eq</span><span class="p">(</span><span class="s2">"Quentin Tarantino"</span><span class="p">)))</span>
<span class="c1"># SELECT movies.* FROM movies WHERE movies.rating &gt;= 7 OR movies.director = 'Quentin Tarantino'</span>
</code></pre></div></div>

<p>However, whether this approach is better than using raw SQL strings is up for debate. On one hand, Arel allows you to inline the values that need to be escaped, so you don’t have to use the <code class="language-plaintext highlighter-rouge">?</code> placeholders. It’s also database agnostic, since you’re building an abstract syntax tree that will be converted to the database-specific SQL by the underlying Active Record adapter.</p>

<p>On the other hand, Arel expressions can get difficult to read as they typically have much more parentheses than their raw SQL counterparts. Also, Arel is considered private API, so it’s not optimized for convenience and it’s subject to change. That’s probably the reason why I also found it very scarcely documented (you won’t find <code class="language-plaintext highlighter-rouge">ActiveRecord::Base.arel_table</code> in the API documentation).</p>

<h2 id="sequel">Sequel</h2>

<p>Sequel’s SQL expression builder API is similar to Arel in the sense that it also builds an abstract syntax tree. However, in Sequel this is public API, it’s optimized for convenience, it’s stable, and it’s very well documented.</p>

<p>We will now walk through various SQL expression types, starting from the most common ones, and show how Sequel always has us covered.</p>

<h3 id="operators">Operators</h3>

<p>We’ve already seen that Arel uses methods for building expressions with SQL operators, which can create a lot of nested parentheses. Sequel, on the other hand, uses actual Ruby operators, which make the expressions naturally readable.</p>

<h4 id="equality-operators">Equality operators</h4>

<p>Sequel can use simple Ruby hashes to do equality and inclusion, just like Active Record:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span>
  <span class="ss">director:     </span><span class="s2">"Quentin Tarantino"</span><span class="p">,</span>    <span class="c1"># string equality</span>
  <span class="ss">genre:        </span><span class="p">[</span><span class="s2">"Adventure"</span><span class="p">,</span> <span class="s2">"Drama"</span><span class="p">],</span> <span class="c1"># set inclusion</span>
  <span class="ss">released:     </span><span class="kp">true</span><span class="p">,</span>                   <span class="c1"># TRUE/FALSE equality</span>
  <span class="ss">premiered_at: </span><span class="kp">nil</span><span class="p">,</span>                    <span class="c1"># NULL equality</span>
<span class="p">)</span>
</code></pre></div></div>

<p>But what if you want to join conditions with <code class="language-plaintext highlighter-rouge">OR</code> instead of <code class="language-plaintext highlighter-rouge">AND</code>? Or you want to use inequality (<code class="language-plaintext highlighter-rouge">&gt;</code>, <code class="language-plaintext highlighter-rouge">&gt;=</code>, <code class="language-plaintext highlighter-rouge">&lt;=</code>, <code class="language-plaintext highlighter-rouge">&lt;</code>) or numeric (<code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code>, <code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">/</code>) operators? Or <code class="language-plaintext highlighter-rouge">LIKE</code> conditions? Sure, you can always switch to raw SQL strings, but with Sequel we can do better.</p>

<p>Sequel gives you the option to break away from hashes by providing an API for building expressions. One of the simplest expression objects is a column identifier:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Sequel</span><span class="p">[</span><span class="ss">:director</span><span class="p">]</span>
<span class="c1"># Sequel::SQL::Identifier: director</span>
</code></pre></div></div>

<p>The basic operators defined on expression objects are <code class="language-plaintext highlighter-rouge">=~</code> (meaning “equals”) and <code class="language-plaintext highlighter-rouge">!~</code> (meaning “not equals”). The result of an operator is again an expression object.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Sequel</span><span class="p">[</span><span class="ss">:director</span><span class="p">]</span> <span class="o">=~</span> <span class="s2">"Quentin Tarantino"</span>
<span class="c1"># Sequel::SQL::BooleanExpression: director = 'Quentin Tarantino'</span>

<span class="no">Sequel</span><span class="p">[</span><span class="ss">:genre</span><span class="p">]</span> <span class="o">!~</span> <span class="s2">"Drama"</span>
<span class="c1"># Sequel::SQL::BooleanExpression: genre != 'Drama'</span>
</code></pre></div></div>

<p>We can go back and rewrite our hash example using Sequel expressions:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span>
  <span class="p">(</span><span class="no">Sequel</span><span class="p">[</span><span class="ss">:director</span><span class="p">]</span>     <span class="o">=~</span> <span class="s2">"Quentin Tarantino"</span><span class="p">)</span>    <span class="o">&amp;</span>
  <span class="p">(</span><span class="no">Sequel</span><span class="p">[</span><span class="ss">:genre</span><span class="p">]</span>        <span class="o">=~</span> <span class="p">[</span><span class="s2">"Adventure"</span><span class="p">,</span> <span class="s2">"Drama"</span><span class="p">])</span> <span class="o">&amp;</span>
  <span class="p">(</span><span class="no">Sequel</span><span class="p">[</span><span class="ss">:released</span><span class="p">]</span>     <span class="o">=~</span> <span class="kp">true</span><span class="p">)</span>                   <span class="o">&amp;</span>
  <span class="p">(</span><span class="no">Sequel</span><span class="p">[</span><span class="ss">:premiered_at</span><span class="p">]</span> <span class="o">=~</span> <span class="kp">nil</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div></div>

<p>This is of course longer and more verbose than the hash version, it’s just to introduce the API, so bear with me.</p>

<p>Now, having to repeat <code class="language-plaintext highlighter-rouge">Sequel[]</code> whenever we want to create an identifier object can be cumbersome, so Sequel offers the virtual row block syntax that automatically creates identifier objects via <code class="language-plaintext highlighter-rouge">method_missing</code>. All you have to do is pass a block to <code class="language-plaintext highlighter-rouge">.where</code> and then you can omit the <code class="language-plaintext highlighter-rouge">Sequel[]</code>:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">where</span><span class="p">{</span>
  <span class="p">(</span><span class="n">director</span>     <span class="o">=~</span> <span class="s2">"Quentin Tarantino"</span><span class="p">)</span>    <span class="o">&amp;</span>
  <span class="p">(</span><span class="n">genre</span>        <span class="o">=~</span> <span class="p">[</span><span class="s2">"Adventure"</span><span class="p">,</span> <span class="s2">"Drama"</span><span class="p">])</span> <span class="o">&amp;</span>
  <span class="p">(</span><span class="n">released</span>     <span class="o">=~</span> <span class="kp">true</span><span class="p">)</span>                   <span class="o">&amp;</span>
  <span class="p">(</span><span class="n">premiered_at</span> <span class="o">=~</span> <span class="kp">nil</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Active Record users might recognize this syntax if they have ever used the Squeel Active Record extension. <a href="https://github.com/activerecord-hackery/squeel">Squeel</a> was heavily inspired by Sequel’s virtual row blocks.</p>

<h4 id="boolean-operators">Boolean operators</h4>

<p>You may have noticed the <code class="language-plaintext highlighter-rouge">&amp;</code> operators between the conditions above. As you might have guessed, Sequel will translate those into <code class="language-plaintext highlighter-rouge">AND</code> in SQL.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="no">Sequel</span><span class="p">[</span><span class="ss">:director</span><span class="p">]</span> <span class="o">=~</span> <span class="s2">"Quentin Tarantino"</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="no">Sequel</span><span class="p">[</span><span class="ss">:genre</span><span class="p">]</span> <span class="o">!~</span> <span class="s2">"Drama"</span><span class="p">)</span>
<span class="c1"># SQL: (director = 'Quentin Tarantino') AND (genre != 'Drama')</span>
</code></pre></div></div>

<p>Up until now there was no benefit of using the expression API over hashes, because we’ve only dealt with equality conditions joined with <code class="language-plaintext highlighter-rouge">AND</code>. If we wanted to use an <code class="language-plaintext highlighter-rouge">OR</code> condition instead, in Active Record we would have to switch to raw SQL. But with Sequel we can just use the <code class="language-plaintext highlighter-rouge">|</code> operator:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="no">Sequel</span><span class="p">[</span><span class="ss">:director</span><span class="p">]</span> <span class="o">=~</span> <span class="s2">"Quentin Tarantino"</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="no">Sequel</span><span class="p">[</span><span class="ss">:genre</span><span class="p">]</span> <span class="o">!~</span> <span class="s2">"Drama"</span><span class="p">)</span>
<span class="c1"># SQL: (director = 'Quentin Tarantino') OR (genre != 'Drama')</span>
</code></pre></div></div>

<p>Note that we have to put parentheses around the clauses, because <code class="language-plaintext highlighter-rouge">&amp;</code> and <code class="language-plaintext highlighter-rouge">|</code> operators have higher predence than <code class="language-plaintext highlighter-rouge">=~</code> and <code class="language-plaintext highlighter-rouge">!~</code>.</p>

<p>You might be wondering why we can’t just use <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> and <code class="language-plaintext highlighter-rouge">||</code> instead of <code class="language-plaintext highlighter-rouge">&amp;</code> and <code class="language-plaintext highlighter-rouge">|</code>. The reason is that <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> and <code class="language-plaintext highlighter-rouge">||</code> are keywords built into the Ruby interpreter, therefore it’s not possible to change their meaning. <code class="language-plaintext highlighter-rouge">&amp;</code> and <code class="language-plaintext highlighter-rouge">|</code>, on the other hand, are just methods which can be overriden like many other operators.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">&amp;</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">|</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The third boolean operator is negation (<code class="language-plaintext highlighter-rouge">NOT</code>). With Sequel we can negate expressions using the <code class="language-plaintext highlighter-rouge">~</code> unary operator:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">~</span><span class="p">((</span><span class="no">Sequel</span><span class="p">[</span><span class="ss">:director</span><span class="p">]</span> <span class="o">=~</span> <span class="s2">"Quentin Tarantino"</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="no">Sequel</span><span class="p">[</span><span class="ss">:genre</span><span class="p">]</span> <span class="o">!~</span> <span class="s2">"Drama"</span><span class="p">))</span>
<span class="c1"># SQL: (director != 'Quentin Tarantino') AND (genre = 'Drama')</span>
</code></pre></div></div>

<p>If you prefer and are able to use plain hashes, you can still use the <code class="language-plaintext highlighter-rouge">&amp;</code>, <code class="language-plaintext highlighter-rouge">|</code>, and <code class="language-plaintext highlighter-rouge">~</code> operators defined on the Sequel module:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="no">Sequel</span><span class="o">.|</span><span class="p">(</span>
  <span class="no">Sequel</span><span class="p">.</span><span class="nf">&amp;</span><span class="p">(</span><span class="ss">genre: </span><span class="s2">"Comedy"</span><span class="p">,</span> <span class="ss">released: </span><span class="kp">true</span><span class="p">),</span>
  <span class="no">Sequel</span><span class="p">.</span><span class="nf">~</span><span class="p">(</span><span class="ss">genre: </span><span class="s2">"Horror"</span><span class="p">),</span>
<span class="p">))</span>
<span class="c1"># SELECT * FROM movies WHERE ((genre = 'Comedy') AND (released IS TRUE)) </span>
</code></pre></div></div>

<h4 id="inequality-operators">Inequality operators</h4>

<p>In addition to the equality operators (<code class="language-plaintext highlighter-rouge">=</code> and <code class="language-plaintext highlighter-rouge">!=</code>), Sequel also defines inequality operators (<code class="language-plaintext highlighter-rouge">&gt;</code>, <code class="language-plaintext highlighter-rouge">&gt;=</code>, <code class="language-plaintext highlighter-rouge">&lt;=</code>, <code class="language-plaintext highlighter-rouge">&lt;</code>) on the expression objects.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Sequel</span><span class="p">[</span><span class="ss">:rating</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">7</span> <span class="c1"># SQL: rating &gt;= 7</span>
</code></pre></div></div>

<p>We can then chain them with boolean operators in the same way:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">where</span><span class="p">((</span><span class="no">Sequel</span><span class="p">[</span><span class="ss">:imdb_rating</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">7.5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="no">Sequel</span><span class="p">[</span><span class="ss">:rotten_tomatoes_rating</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">))</span>
<span class="c1"># SELECT * FROM movies WHERE imdb_rating &gt; 7.5 AND rotten_tomatoes_rating &gt;= 6</span>
</code></pre></div></div>

<p>And use virtual row blocks:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">where</span><span class="p">{(</span><span class="n">imdb_rating</span> <span class="o">&gt;</span> <span class="mf">7.5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rotten_tomatoes_rating</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">)}</span>
<span class="c1"># SELECT * FROM movies WHERE imdb_rating &gt; 7.5 AND rotten_tomatoes_rating &gt;= 6</span>
</code></pre></div></div>

<h4 id="numeric-and-string-operators">Numeric and String operators</h4>

<p>The expression objects also define some numeric operators we’d expect:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Sequel</span><span class="p">[</span><span class="ss">:order</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1"># SQL: order + 2</span>
<span class="no">Sequel</span><span class="p">[</span><span class="ss">:order</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="c1"># SQL: order - 2</span>
<span class="no">Sequel</span><span class="p">[</span><span class="ss">:order</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="c1"># SQL: order * 2</span>
<span class="no">Sequel</span><span class="p">[</span><span class="ss">:order</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="c1"># SQL: order / 2</span>
</code></pre></div></div>

<p>On string expressions <code class="language-plaintext highlighter-rouge">+</code> is defined as concatenation:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Sequel</span><span class="p">[</span><span class="ss">:first_name</span><span class="p">]</span> <span class="o">+</span> <span class="s2">" "</span> <span class="o">+</span> <span class="no">Sequel</span><span class="p">[</span><span class="ss">:last_name</span><span class="p">]</span>
<span class="c1"># SQL: first_name || ' ' || last_name</span>
</code></pre></div></div>

<h3 id="qualifying">Qualifying</h3>

<p>Sequel doesn’t automatically qualify column identifiers, because SQL doesn’t either.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">name: </span><span class="s2">"Matrix"</span><span class="p">)</span>
<span class="c1"># ActiveRecord: SELECT movies.* FROM movies WHERE movies.name = 'Matrix'</span>
<span class="c1"># Sequel:       SELECT * FROM movies WHERE name = 'Matrix'</span>
</code></pre></div></div>

<p>To qualify a column identifier with a table name, you can call another square brackets on the identifier:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="no">Sequel</span><span class="p">[</span><span class="ss">:movies</span><span class="p">][</span><span class="ss">:name</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="s2">"Matrix"</span><span class="p">)</span>
<span class="no">Movie</span><span class="p">.</span><span class="nf">where</span><span class="p">{</span><span class="n">movies</span><span class="p">[</span><span class="ss">:name</span><span class="p">]</span> <span class="o">=~</span> <span class="s2">"Matrix"</span><span class="p">}</span>
<span class="c1"># SELECT * FROM movies WHERE movies.name = 'Matrix'</span>
</code></pre></div></div>

<p>You can also qualify whole expressions with <code class="language-plaintext highlighter-rouge">Sequel.deep_qualify</code>:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Sequel</span><span class="p">.</span><span class="nf">deep_qualify</span><span class="p">(</span><span class="ss">:movies</span><span class="p">,</span>
  <span class="p">(</span><span class="no">Sequel</span><span class="p">[</span><span class="ss">:imdb_rating</span><span class="p">]</span> <span class="o">+</span> <span class="no">Sequel</span><span class="p">[</span><span class="ss">:rotten_tomatoes_rating</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&amp;</span>
  <span class="p">(</span><span class="no">Sequel</span><span class="p">[</span><span class="ss">:released_at</span><span class="p">].</span><span class="nf">extract</span><span class="p">(</span><span class="ss">:year</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2000</span><span class="p">)</span>
<span class="p">)</span>
<span class="c1"># SQL: (movies.imdb_rating + movies.rotten_tomatoes_rating &gt;= 10) AND</span>
<span class="c1">#      (extract(year FROM movies.released_at) &gt;= 2000)</span>
</code></pre></div></div>

<p>To just qualify all column identifiers in a dataset, use <code class="language-plaintext highlighter-rouge">Sequel::Dataset#qualify</code>:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:name</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">genre: </span><span class="s2">"Adventure"</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="ss">:rating</span><span class="p">)</span>
<span class="c1"># SELECT name FROM movies WHERE (genre = 'Adventure') ORDER BY rating</span>
<span class="no">Movie</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:name</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">genre: </span><span class="s2">"Adventure"</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="ss">:rating</span><span class="p">).</span><span class="nf">qualify</span>
<span class="c1"># SELECT movies.name FROM movies WHERE (movies.genre = 'Adventure') ORDER BY movies.rating</span>
</code></pre></div></div>

<p>Active Record does have the more convenient hash syntax for qualifying <code class="language-plaintext highlighter-rouge">#where</code> conditions. However, I don’t find it ideal to have to nest conditions that have the same level of importance.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ActiveRecord</span>
<span class="no">Movie</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:rating</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">where</span><span class="p">(</span>
    <span class="ss">released: </span><span class="kp">true</span><span class="p">,</span>     <span class="c1"># movies.released IS TRUE</span>
    <span class="ss">rating: </span><span class="p">{</span> <span class="ss">imdb: </span><span class="mi">7</span> <span class="p">}</span> <span class="c1"># rating.imdb = 7</span>
  <span class="p">)</span>

<span class="c1"># Sequel</span>
<span class="no">Movie</span><span class="p">.</span><span class="nf">association_join</span><span class="p">(</span><span class="ss">:rating</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">where</span><span class="p">{</span>
    <span class="p">(</span><span class="n">released</span>     <span class="o">=~</span> <span class="kp">true</span><span class="p">)</span> <span class="o">&amp;</span> <span class="c1"># movies.released IS TRUE</span>
    <span class="p">(</span><span class="n">rating</span><span class="p">[</span><span class="n">imdb</span><span class="p">]</span> <span class="o">=~</span> <span class="mi">7</span><span class="p">)</span>      <span class="c1"># rating.imdb = 7</span>
  <span class="p">}</span>
</code></pre></div></div>

<h3 id="ordering">Ordering</h3>

<p>Ordered expressions can be created with <code class="language-plaintext highlighter-rouge">Sequel.asc</code> and <code class="language-plaintext highlighter-rouge">Sequel.desc</code>:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Sequel</span><span class="p">.</span><span class="nf">desc</span><span class="p">(</span><span class="ss">:rating</span><span class="p">)</span>
<span class="c1"># Sequel::SQL::OrderedExpression: rating DESC</span>
<span class="no">Sequel</span><span class="p">.</span><span class="nf">asc</span><span class="p">(</span><span class="ss">:rating</span><span class="p">)</span>
<span class="c1"># Sequel::SQL::OrderedExpression: rating ASC</span>
</code></pre></div></div>

<p>These can then be passed to <code class="language-plaintext highlighter-rouge">#order</code>:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="no">Sequel</span><span class="p">.</span><span class="nf">desc</span><span class="p">(</span><span class="ss">:rating</span><span class="p">))</span>
<span class="no">Movie</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="no">Sequel</span><span class="p">[</span><span class="ss">:rating</span><span class="p">].</span><span class="nf">desc</span><span class="p">)</span>
<span class="no">Movie</span><span class="p">.</span><span class="nf">order</span><span class="p">{</span><span class="n">rating</span><span class="p">.</span><span class="nf">desc</span><span class="p">}</span>
<span class="c1"># SELECT * FROM movies ORDER rating DESC</span>
</code></pre></div></div>

<p>When I first came to Sequel after having used Active Record for many years, I was wondering if there was something like <code class="language-plaintext highlighter-rouge">order(rating: :desc)</code> in Sequel. Jeremy explained that this syntax would violate the general rule in Sequel that hashes are used for equality expressions. I also came to realize how flexible is that <code class="language-plaintext highlighter-rouge">#asc</code> and <code class="language-plaintext highlighter-rouge">#desc</code> are methods.</p>

<p>For example, that allows Sequel to support <code class="language-plaintext highlighter-rouge">NULLS FIRST</code> and <code class="language-plaintext highlighter-rouge">NULLS LAST</code> via the <code class="language-plaintext highlighter-rouge">:nulls</code> option:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">order</span><span class="p">{</span><span class="n">rating</span><span class="p">.</span><span class="nf">desc</span><span class="p">(</span><span class="ss">nulls: :last</span><span class="p">)}</span>
<span class="c1"># SELECT * FROM movies ORDER BY rating DESC NULLS LAST</span>
</code></pre></div></div>

<p>You can also order by any complex expressions:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">order</span><span class="p">{(</span><span class="n">imdb_rating</span> <span class="o">+</span> <span class="n">rotten_tomatoes_rating</span><span class="p">).</span><span class="nf">desc</span><span class="p">}</span>
<span class="c1"># SELECT * FROM movies ORDER BY (imdb_rating + rotten_tomatoes_rating) DESC</span>
</code></pre></div></div>

<p>Since ordered expressions are expressions, Sequel will recognize them anywhere, even for example in parameters for a window function:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">select</span><span class="p">{</span><span class="n">row_number</span><span class="p">.</span><span class="nf">function</span><span class="p">.</span><span class="nf">over</span><span class="p">(</span><span class="ss">partition: :director</span><span class="p">,</span> <span class="ss">order: </span><span class="n">released_at</span><span class="p">.</span><span class="nf">asc</span><span class="p">)}</span>
<span class="c1"># SELECT row_number() OVER (PARTITION BY director ORDER BY released_at ASC) FROM movies</span>
</code></pre></div></div>

<h3 id="like">LIKE</h3>

<p>Sequel supports <code class="language-plaintext highlighter-rouge">LIKE</code> and <code class="language-plaintext highlighter-rouge">ILIKE</code> expressions via <code class="language-plaintext highlighter-rouge">#like</code> and <code class="language-plaintext highlighter-rouge">#ilike</code> methods:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Sequel</span><span class="p">.</span><span class="nf">like</span><span class="p">(</span><span class="ss">:title</span><span class="p">,</span> <span class="s2">"Summer%"</span><span class="p">)</span>
<span class="c1"># Sequel::SQL::BooleanExpression: title LIKE 'Summer%'</span>
<span class="no">Sequel</span><span class="p">.</span><span class="nf">ilike</span><span class="p">(</span><span class="ss">:title</span><span class="p">,</span> <span class="s2">"summer%"</span><span class="p">)</span>
<span class="c1"># Sequel::SQL::BooleanExpression: title ILIKE 'Summer%'</span>
</code></pre></div></div>

<p>They can then be used in <code class="language-plaintext highlighter-rouge">#where</code>:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="no">Sequel</span><span class="p">.</span><span class="nf">like</span><span class="p">(</span><span class="ss">:title</span><span class="p">,</span> <span class="s2">"Summer%"</span><span class="p">))</span>
<span class="no">Movie</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="no">Sequel</span><span class="p">[</span><span class="ss">:title</span><span class="p">].</span><span class="nf">like</span><span class="p">(</span><span class="s2">"Summer%"</span><span class="p">))</span>
<span class="no">Movie</span><span class="p">.</span><span class="nf">where</span><span class="p">{</span><span class="n">title</span><span class="p">.</span><span class="nf">like</span><span class="p">(</span><span class="s2">"Summer%"</span><span class="p">)}</span>
<span class="c1"># SELECT * FROM movies WHERE title LIKE 'Summer%'</span>
</code></pre></div></div>

<p>Here is an example of creating filter expression that matches a search term onto multiple columns:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">filter</span> <span class="o">=</span> <span class="p">[</span><span class="ss">:title</span><span class="p">,</span> <span class="ss">:summary</span><span class="p">,</span> <span class="ss">:director</span><span class="p">]</span>
  <span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">column</span><span class="o">|</span> <span class="no">Sequel</span><span class="p">.</span><span class="nf">ilike</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="s2">"%</span><span class="si">#{</span><span class="n">search_term</span><span class="si">}</span><span class="s2">%"</span><span class="p">)</span> <span class="p">}</span>
  <span class="p">.</span><span class="nf">inject</span><span class="p">(</span><span class="ss">:&amp;</span><span class="p">)</span>

<span class="no">Movie</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">filter</span><span class="p">)</span>
<span class="c1"># SELECT * FROM movies WHERE title ILIKE '%foo%' AND summary ILIKE '%foo%' AND director ILIKE '%foo%'</span>
</code></pre></div></div>

<h3 id="functions">Functions</h3>

<p>Some SQL functions have their dedicated API in Sequel, but in general Sequel supports calling any SQL function. <code class="language-plaintext highlighter-rouge">Sequel.function</code> can be used to create a function expression; the first argument is the function name and the rest are function arguments.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Sequel</span><span class="p">.</span><span class="nf">function</span><span class="p">(</span><span class="ss">:max</span><span class="p">,</span> <span class="ss">:rating</span><span class="p">)</span> <span class="c1"># SQL: max(rating)</span>
</code></pre></div></div>

<p>They can then be used in places like <code class="language-plaintext highlighter-rouge">#select</code>:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="no">Sequel</span><span class="p">.</span><span class="nf">function</span><span class="p">(</span><span class="ss">:max</span><span class="p">,</span> <span class="ss">:rating</span><span class="p">))</span>
<span class="c1"># SELECT max(rating) FROM movies</span>
</code></pre></div></div>

<p>To create <code class="language-plaintext highlighter-rouge">count(*)</code>, you can use the <code class="language-plaintext highlighter-rouge">*</code> unary operator:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="no">Sequel</span><span class="p">.</span><span class="nf">function</span><span class="p">(</span><span class="ss">:count</span><span class="p">).</span><span class="nf">*</span><span class="p">)</span>
<span class="c1"># SELECT count(*) FROM movies</span>
</code></pre></div></div>

<p>Sequel’s virtual row blocks make calling SQL functions more convenient via <code class="language-plaintext highlighter-rouge">method_missing</code>. An undefined method called with arguments will automatically be converted into a function, whereas to create a function without arguments you’ll need to add a call to <code class="language-plaintext highlighter-rouge">#function</code>.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">select</span><span class="p">{</span><span class="n">max</span><span class="p">(</span><span class="n">rating</span><span class="p">)}</span>         <span class="c1"># SELECT max(rating)  FROM movies</span>
<span class="no">Movie</span><span class="p">.</span><span class="nf">select</span><span class="p">{</span><span class="n">row_number</span><span class="p">.</span><span class="nf">function</span><span class="p">}</span> <span class="c1"># SELECT row_number() FROM movies</span>
<span class="no">Movie</span><span class="p">.</span><span class="nf">select</span><span class="p">{</span><span class="n">count</span><span class="p">.</span><span class="nf">function</span><span class="p">.</span><span class="nf">*</span><span class="p">}</span>    <span class="c1"># SELECT count(*)     FROM movies</span>
</code></pre></div></div>

<p>This means you can easily convert even complex SQL queries into Sequel:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">coalesce</span><span class="p">(</span><span class="n">first_name</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span> <span class="o">||</span> <span class="s1">' '</span> <span class="o">||</span> <span class="n">coalesce</span><span class="p">(</span><span class="n">last_name</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span> <span class="k">AS</span> <span class="n">full_name</span>
<span class="k">FROM</span> <span class="n">users</span>
<span class="k">WHERE</span> <span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">created_at</span> <span class="o">&lt;=</span> <span class="mi">24</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="k">lower</span><span class="p">(</span><span class="n">full_name</span><span class="p">)</span>
</code></pre></div></div>
<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">User</span>
  <span class="p">.</span><span class="nf">select</span><span class="p">{(</span><span class="n">coalesce</span><span class="p">(</span><span class="ss">:first_name</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span> <span class="o">+</span> <span class="s1">' '</span> <span class="o">+</span> <span class="n">coalesce</span><span class="p">(</span><span class="ss">:last_name</span><span class="p">,</span> <span class="s1">''</span><span class="p">)).</span><span class="nf">as</span><span class="p">(</span><span class="ss">:full_name</span><span class="p">)}</span>
  <span class="p">.</span><span class="nf">where</span><span class="p">{(</span><span class="n">now</span><span class="p">.</span><span class="nf">function</span> <span class="o">-</span> <span class="ss">:created_at</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">24</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="mi">60</span><span class="p">}</span>
  <span class="p">.</span><span class="nf">order</span><span class="p">{</span><span class="n">lower</span><span class="p">(</span><span class="ss">:full_name</span><span class="p">)}</span>
</code></pre></div></div>

<p>In Arel you have the <code class="language-plaintext highlighter-rouge">Arel::Nodes::NamedFunction</code> counterpart, but using it is much more verbose:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ActiveRecord</span>
<span class="no">User</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">NamedFunction</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"coalesce"</span><span class="p">,</span> <span class="p">[</span><span class="no">User</span><span class="p">.</span><span class="nf">arel_table</span><span class="p">[</span><span class="ss">:first_name</span><span class="p">],</span> <span class="no">Arel</span><span class="p">.</span><span class="nf">sql</span><span class="p">(</span><span class="s2">"''"</span><span class="p">)]))</span>
<span class="c1"># SELECT coalesce(users.first_name, '') FROM users</span>
</code></pre></div></div>

<h3 id="aliasing">Aliasing</h3>

<p>Sequel provides support for aliasing via the <code class="language-plaintext highlighter-rouge">#as</code> method. You can alias anything from column identifiers:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="no">Sequel</span><span class="p">.</span><span class="nf">as</span><span class="p">(</span><span class="ss">:imdb_rating</span><span class="p">,</span> <span class="ss">:rating</span><span class="p">))</span>
<span class="c1"># SELECT imdb_rating AS rating FROM movies</span>
</code></pre></div></div>

<p>to expressions:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">User</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="no">Sequel</span><span class="p">.</span><span class="nf">join</span><span class="p">([</span><span class="ss">:first_name</span><span class="p">,</span> <span class="ss">:last_name</span><span class="p">],</span> <span class="s1">' '</span><span class="p">).</span><span class="nf">as</span><span class="p">(</span><span class="ss">:full_name</span><span class="p">))</span>
<span class="c1"># SELECT (first_name || ' ' || last_name) AS full_name FROM users</span>
</code></pre></div></div>

<p>and even whole datasets:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">User</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="no">UserActivityLog</span><span class="p">.</span><span class="nf">order</span><span class="p">{</span><span class="n">created_at</span><span class="p">.</span><span class="nf">desc</span><span class="p">}.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">100</span><span class="p">).</span><span class="nf">as</span><span class="p">(</span><span class="ss">:logs</span><span class="p">),</span> <span class="ss">user_id: :id</span><span class="p">)</span>
<span class="c1"># SELECT * FROM users JOIN (</span>
<span class="c1">#   SELECT * FROM user_activity_logs ORDER BY created_at DESC LIMIT 100</span>
<span class="c1"># ) AS logs ON (logs.user_id = users.id)</span>
</code></pre></div></div>

<p>Arel also has <code class="language-plaintext highlighter-rouge">#as</code> for aliasing, but for some reason it’s not available for all types of expressions:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ActiveRecord</span>
<span class="no">Movie</span><span class="p">.</span><span class="nf">arel_table</span><span class="p">[</span><span class="ss">:rating</span><span class="p">].</span><span class="nf">as</span><span class="p">(</span><span class="s2">"total_rating"</span><span class="p">)</span>
<span class="c1"># SQL: rating AS total_rating</span>
<span class="p">(</span><span class="no">Movie</span><span class="p">.</span><span class="nf">arel_table</span><span class="p">[</span><span class="ss">:imdb_rating</span><span class="p">]</span> <span class="o">+</span> <span class="no">Movie</span><span class="p">.</span><span class="nf">arel_table</span><span class="p">[</span><span class="ss">:netflix_rating</span><span class="p">]).</span><span class="nf">as</span><span class="p">(</span><span class="s2">"total_rating"</span><span class="p">)</span>
<span class="c1"># ~&gt; NoMethodError: undefined method `as' for #&lt;Arel::Nodes::Grouping:0x00007fb915477e28&gt;</span>
</code></pre></div></div>

<h3 id="case">CASE</h3>

<p>You can build <code class="language-plaintext highlighter-rouge">CASE</code> statements with <code class="language-plaintext highlighter-rouge">Sequel.case</code>, where first argument is the hash of <code class="language-plaintext highlighter-rouge">WHERE</code>/<code class="language-plaintext highlighter-rouge">THEN</code> conditions, second argument is the <code class="language-plaintext highlighter-rouge">ELSE</code> default value, and the third optional argument is the <code class="language-plaintext highlighter-rouge">CASE</code> expression.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Sequel</span><span class="p">.</span><span class="nf">case</span><span class="p">(</span>                          <span class="c1"># CASE</span>
  <span class="p">{</span>
    <span class="p">(</span><span class="no">Sequel</span><span class="p">[</span><span class="ss">:rating</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">"good"</span><span class="p">,</span> <span class="c1"># WHEN rating &gt;= 8 THEN 'good'</span>
    <span class="p">(</span><span class="no">Sequel</span><span class="p">[</span><span class="ss">:rating</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">"ok"</span><span class="p">,</span>   <span class="c1"># WHEN rating &gt;= 6 THEN 'ok'</span>
    <span class="p">(</span><span class="no">Sequel</span><span class="p">[</span><span class="ss">:rating</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">"bad"</span><span class="p">,</span>  <span class="c1"># WHEN rating &gt;= 4 THEN 'bad'</span>
  <span class="p">},</span>
  <span class="s2">"abysmal"</span>                           <span class="c1"># ELSE 'abysmal'</span>
<span class="p">)</span>
</code></pre></div></div>

<p>A few years ago I made a pull request to RubyGems.org, which added a Rake task that syncs cached download counts from Redis into the Postgres database. Since the <code class="language-plaintext highlighter-rouge">rubygems</code> table has many rows, I didn’t want to execute an <code class="language-plaintext highlighter-rouge">UPDATE</code> query for each row, so I built a <code class="language-plaintext highlighter-rouge">CASE</code> statement in SQL:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">case_query</span> <span class="o">=</span> <span class="no">Rubygem</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="s2">"WHEN '</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">' THEN </span><span class="si">#{</span><span class="vg">$redis</span><span class="p">[</span><span class="s2">"downloads:rubygem:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span><span class="p">].</span><span class="nf">to_i</span><span class="si">}</span><span class="s2">"</span> <span class="p">}</span>
  <span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">            "</span><span class="p">)</span>

<span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">connection</span><span class="p">.</span><span class="nf">execute</span> <span class="o">&lt;&lt;-</span><span class="no">SQL</span><span class="p">.</span><span class="nf">strip_heredoc</span><span class="sh">
  UPDATE rubygems
    SET downloads = CASE name
      </span><span class="si">#{</span><span class="n">case_query</span><span class="si">}</span><span class="sh">
    END
</span><span class="no">SQL</span>
</code></pre></div></div>

<p>With Sequel this whole expression can be created in Ruby:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">counts_by_name</span> <span class="o">=</span> <span class="no">Rubygem</span><span class="p">.</span><span class="nf">select_map</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="p">[</span><span class="nb">name</span><span class="p">,</span> <span class="vg">$redis</span><span class="p">[</span><span class="s2">"downloads:rubygem:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span><span class="p">].</span><span class="nf">to_i</span><span class="p">]</span> <span class="p">}</span>

<span class="no">Rubygem</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="ss">downloads: </span><span class="no">Sequel</span><span class="p">.</span><span class="nf">case</span><span class="p">(</span><span class="n">counts_by_name</span><span class="p">,</span> <span class="ss">:downloads</span><span class="p">,</span> <span class="ss">:name</span><span class="p">))</span>
</code></pre></div></div>

<p>Arel also has its own <code class="language-plaintext highlighter-rouge">Arel::Nodes::Case</code>, which is built incrementally. However, Active Record’s <code class="language-plaintext highlighter-rouge">#update_all</code> method doesn’t seem to accept Arel expressions, because this case expression gets converted to <code class="language-plaintext highlighter-rouge">NULL</code>.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">download_counts</span> <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">Case</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">Rubygem</span><span class="p">.</span><span class="nf">arel_table</span><span class="p">[</span><span class="ss">:name</span><span class="p">])</span>

<span class="no">Rubygem</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:name</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">map</span>  <span class="p">{</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="p">[</span><span class="nb">name</span><span class="p">,</span> <span class="vg">$redis</span><span class="p">[</span><span class="s2">"downloads:rubygem:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span><span class="p">].</span><span class="nf">to_i</span><span class="p">]</span> <span class="p">}</span>
  <span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="nb">name</span><span class="p">,</span> <span class="n">count</span><span class="o">|</span> <span class="n">download_counts</span><span class="p">.</span><span class="nf">when</span><span class="p">(</span><span class="nb">name</span><span class="p">).</span><span class="nf">then</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="p">}</span>

<span class="n">download_counts</span><span class="p">.</span><span class="nf">else</span><span class="p">(</span><span class="no">Rubygem</span><span class="p">.</span><span class="nf">arel_table</span><span class="p">[</span><span class="ss">:downloads</span><span class="p">])</span>

<span class="no">Rubygem</span><span class="p">.</span><span class="nf">update_all</span><span class="p">(</span><span class="ss">downloads: </span><span class="n">download_counts</span><span class="p">)</span>
<span class="c1"># UPDATE "rubygems" SET "downloads" = NULL</span>
</code></pre></div></div>

<h3 id="array--json-operations">Array &amp; JSON operations</h3>

<p>The last type of expressions we’ll cover are operations with Postgres Array and JSON types. These operations include operators and function names that can be difficult to remember, and Sequel provides a convenience API via the <a href="https://sequel.jeremyevans.net/rdoc-plugins/files/lib/sequel/extensions/pg_array_ops_rb.html">pg_array_ops</a> and <a href="https://sequel.jeremyevans.net/rdoc-plugins/files/lib/sequel/extensions/pg_json_ops_rb.html">pg_json_ops</a> extensions (see <a href="https://sequel.jeremyevans.net/rdoc/files/doc/extensions_rdoc.html">this document</a> for more on Sequel extensions).</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">DB</span><span class="p">.</span><span class="nf">extension</span> <span class="ss">:pg_array</span><span class="p">,</span> <span class="ss">:pg_json</span>             <span class="c1"># load support for array and json types</span>
<span class="no">Sequel</span><span class="p">.</span><span class="nf">extension</span> <span class="ss">:pg_array_ops</span><span class="p">,</span> <span class="ss">:pg_json_ops</span> <span class="c1"># load methods for building array/json expressions</span>
</code></pre></div></div>

<p>We first need to create an array/json expression by calling <code class="language-plaintext highlighter-rouge">#pg_array</code> and <code class="language-plaintext highlighter-rouge">#pg_jsonb</code>, and then we can call operation methods on that object.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span><span class="p">.</span><span class="nf">where</span><span class="p">{</span>
  <span class="n">genres</span><span class="p">.</span><span class="nf">pg_array</span><span class="p">.</span><span class="nf">contains</span><span class="p">([</span><span class="s2">"Adventure"</span><span class="p">,</span> <span class="s2">"Comedy"</span><span class="p">])</span> <span class="o">&amp;</span>
  <span class="p">(</span><span class="n">imdb</span><span class="p">.</span><span class="nf">pg_jsonb</span><span class="p">[</span><span class="s1">'Rating'</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">7</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1"># SELECT * FROM movies WHERE (</span>
<span class="c1">#   (genres @&gt; ARRAY['Adventure','Comedy']) AND</span>
<span class="c1">#   ((imdb_data -&gt; 'Rating') &gt;= 7)</span>
<span class="c1"># )</span>
</code></pre></div></div>

<p>If you want to avoid repeating <code class="language-plaintext highlighter-rouge">#pg_array</code> or <code class="language-plaintext highlighter-rouge">#pg_jsonb</code> in your queries, you can save the array/json expression object into a variable or a constant.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">genres</span> <span class="o">=</span> <span class="no">Sequel</span><span class="p">.</span><span class="nf">pg_array</span><span class="p">(</span><span class="ss">:genres</span><span class="p">)</span>
<span class="n">imdb</span>   <span class="o">=</span> <span class="no">Sequel</span><span class="p">.</span><span class="nf">pg_jsonb</span><span class="p">(</span><span class="ss">:imdb</span><span class="p">)</span>

<span class="no">Movie</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">genres</span><span class="p">.</span><span class="nf">contains</span><span class="p">([</span><span class="s2">"Adventure"</span><span class="p">,</span> <span class="s2">"Comedy"</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">imdb</span><span class="p">[</span><span class="s1">'Rating'</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">7</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="other-uses">Other uses</h2>

<p>Other than for building queries, Sequel supports the expression API in many other areas where SQL expressions are needed.</p>

<p>For instance, you can use them when creating an index:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">create_table</span> <span class="ss">:users</span> <span class="k">do</span>
  <span class="n">primary_key</span> <span class="ss">:id</span>

  <span class="no">String</span>   <span class="ss">:handle</span>
  <span class="no">DateTime</span> <span class="ss">:deleted_at</span>

  <span class="n">index</span> <span class="no">Sequel</span><span class="p">.</span><span class="nf">function</span><span class="p">(</span><span class="ss">:lower</span><span class="p">,</span> <span class="ss">:handle</span><span class="p">),</span>
    <span class="ss">name: :users_unique_handle</span><span class="p">,</span>
    <span class="ss">unique: </span><span class="kp">true</span><span class="p">,</span>
    <span class="ss">where: </span><span class="no">Sequel</span><span class="p">[</span><span class="ss">:deleted_at</span><span class="p">]</span> <span class="o">!~</span> <span class="kp">nil</span>

  <span class="c1"># CREATE UNIQUE INDEX users_unique_handle</span>
  <span class="c1"># ON users (lower(handle))</span>
  <span class="c1"># WHERE (deleted_at IS NOT NULL)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Another example is the <code class="language-plaintext highlighter-rouge">USING</code> statement when changing column type:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">alter_table</span> <span class="ss">:albums</span> <span class="k">do</span>
  <span class="n">set_column_type</span> <span class="ss">:artist_id</span><span class="p">,</span> <span class="ss">:integer</span><span class="p">,</span> <span class="ss">using: </span><span class="no">Sequel</span><span class="p">[</span><span class="ss">:artist_id</span><span class="p">].</span><span class="nf">cast</span><span class="p">(</span><span class="no">Integer</span><span class="p">)</span>
  <span class="c1"># ALTER COLUMN artist_id SET DATA TYPE integer USING CAST(artist_id AS integer)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Yet another area where expressions are supported is in Sequel’s <a href="https://sequel.jeremyevans.net/rdoc/files/doc/postgresql_rdoc.html#label-INSERT+ON+CONFLICT+Support">UPSERT method</a>:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Movie</span>
  <span class="p">.</span><span class="nf">insert_conflict</span><span class="p">(</span>
    <span class="ss">update: </span><span class="p">{</span> <span class="ss">imdb: </span><span class="no">Sequel</span><span class="p">.</span><span class="nf">pg_jsonb</span><span class="p">(</span><span class="ss">:imdb</span><span class="p">).</span><span class="nf">concat</span><span class="p">(</span><span class="no">Sequel</span><span class="p">[</span><span class="ss">:excluded</span><span class="p">][</span><span class="ss">:imdb</span><span class="p">])</span> <span class="p">},</span>
    <span class="ss">update_where: </span><span class="no">Sequel</span><span class="p">[</span><span class="ss">:year</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2000</span><span class="p">,</span>
  <span class="p">)</span>
  <span class="p">.</span><span class="nf">multi_insert</span><span class="p">(</span><span class="n">imported_values</span><span class="p">)</span>

<span class="c1"># INSERT INTO movies VALUES ...</span>
<span class="c1"># ON CONFLICT DO</span>
<span class="c1"># UPDATE SET imdb = (imdb || excluded.imdb)</span>
<span class="c1"># WHERE (year &gt;= 2000)</span>
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>Sequel’s API for building SQL expressions allows you to consistently stay in Ruby even for very advanced use cases. This has numerous advantages:</p>

<ul>
  <li>it’s more readable, with different styles to choose from</li>
  <li>it’s more hackable and reusable</li>
  <li>doesn’t require you to look up the correct SQL syntax every time</li>
  <li>eliminates the possibility of SQL injections</li>
</ul>

<p>We’re much more motivated to use the various features our database has to offer when our database library encourages us to.</p>


  </div>
</article>

<div class="mt-8 md:mt-10">
  <div class="flex items-center space-x-4 md:space-x-6 mx-0 lg:-mx-6 bg-blue-50 border border-sky-200 bg-sky-50 px-4 py-3 md:py-5 md:px-6 rounded-xl overflow-x-scroll dark:bg-sky-950 dark:border-sky-600">
  <img src="/images/me.jpg" class="h-20 w-20 xs:h-24 xs:w-24 sm:h-32 sm:w-32 rounded-xl">
  <div class="flex flex-col justify-center">
    
      <h3 class="font-medium text-slate-900 dark:text-slate-200 mb-2 text-xl xs:text-2xl">
        Janko Marohnić
      </h3>
    
    <p class="text-slate-900 dark:text-slate-200 text-sm xs:text-base md:text-lg hidden sm:block">
      Ruby developer, Rails critic, open source maintainer, creator of
      <a class="text-pink-700 underline dark:text-pink-500 decoration-pink-700/30 transition hover:text-pink-800 hover:decoration-pink-800 dark:hover:text-pink-400 dark:decoration-pink-500/40 dark:hover:decoration-pink-400" href="https://shrinerb.com" target="_blank">Shrine</a>,
      <a class="text-pink-700 underline dark:text-pink-500 decoration-pink-700/30 transition hover:text-pink-800 hover:decoration-pink-800 dark:hover:text-pink-400 dark:decoration-pink-500/40 dark:hover:decoration-pink-400" href="https://github.com/vim-test/vim-test" target="_blank">vim-test</a> and
      <a class="text-pink-700 underline dark:text-pink-500 decoration-pink-700/30 transition hover:text-pink-800 hover:decoration-pink-800 dark:hover:text-pink-400 dark:decoration-pink-500/40 dark:hover:decoration-pink-400" href="https://github.com/janko/rodauth-rails" target="_blank">rodauth-rails</a>.
    </p>

    <div class="mt-2 xs:mt-4 sm:mt-5 flex items-center space-x-3 xs:space-x-5">
      

      <a href="https://github.com/janko" title="GitHub" target="_blank">
        <svg class="w-5 h-5 xs:w-6 xs:h-6 sm:w-7 sm:h-7 transition hover:scale-[1.2] duration-200 ease-in ease-out dark:hidden" viewBox="0 0 24 24">
          <path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path>
        </svg>
        <svg class="w-5 h-5 xs:w-6 xs:h-6 sm:w-7 sm:h-7 transition hover:scale-[1.2] duration-200 ease-in ease-out hidden dark:block" viewBox="0 0 100 100">
          <path fill-rule="evenodd" clip-rule="evenodd" d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z" fill="#fff"/>
        </svg>
      </a>
      <a href="https://twitter.com/jankomarohnic" title="Twitter" target="_blank">
        <svg class="w-5 h-5 xs:w-6 xs:h-6 sm:w-7 sm:h-7 transition hover:scale-[1.2] duration-200 ease-in ease-out" viewBox="0 0 20 20" fill="currentColor">
          <path fill="#1d9bf0" d="M17.316 6.246c0.008 0.162 0.011 0.326 0.011 0.488 0 4.99-3.797 10.742-10.74 10.742-2.133 0-4.116-0.625-5.787-1.697 0.296 0.035 0.596 0.053 0.9 0.053 1.77 0 3.397-0.604 4.688-1.615-1.651-0.031-3.046-1.121-3.526-2.621 0.23 0.043 0.467 0.066 0.71 0.066 0.345 0 0.679-0.045 0.995-0.131-1.727-0.348-3.028-1.873-3.028-3.703 0-0.016 0-0.031 0-0.047 0.509 0.283 1.092 0.453 1.71 0.473-1.013-0.678-1.68-1.832-1.68-3.143 0-0.691 0.186-1.34 0.512-1.898 1.861 2.285 4.644 3.787 7.781 3.945-0.064-0.277-0.097-0.564-0.097-0.861 0-2.084 1.689-3.773 3.774-3.773 1.086 0 2.067 0.457 2.756 1.191 0.859-0.17 1.667-0.484 2.397-0.916-0.282 0.881-0.881 1.621-1.66 2.088 0.764-0.092 1.49-0.293 2.168-0.594-0.506 0.758-1.146 1.422-1.884 1.953z"></path>
        </svg>
      </a>
      <a href="https://www.youtube.com/@jankomarohnic" title="YouTube" target="_blank">
        <svg class="w-5 h-5 xs:w-6 xs:h-6 sm:w-7 sm:h-7 transition hover:scale-[1.2] duration-200 ease-in ease-out" viewBox="0 0 159 110" fill="currentColor">
          <path d="m154 17.5c-1.82-6.73-7.07-12-13.8-13.8-9.04-3.49-96.6-5.2-122 0.1-6.73 1.82-12 7.07-13.8 13.8-4.08 17.9-4.39 56.6 0.1 74.9 1.82 6.73 7.07 12 13.8 13.8 17.9 4.12 103 4.7 122 0 6.73-1.82 12-7.07 13.8-13.8 4.35-19.5 4.66-55.8-0.1-75z" fill="#f00"/>
          <path d="m105 55-40.8-23.4v46.8z" fill="#fff"/>
        </svg>
      </a>
      <a href="https://www.linkedin.com/in/janko-marohnic/" title="LinkedIn" target="_blank">
        <svg class="w-5 h-5 xs:w-6 xs:h-6 sm:w-7 sm:h-7 transition hover:scale-[1.2] duration-200 ease-in ease-out" viewBox="0 0 72 72" width="72">
          <g fill="none" fill-rule="evenodd"><path d="M8,72 L64,72 C68.418278,72 72,68.418278 72,64 L72,8 C72,3.581722 68.418278,-8.11624501e-16 64,0 L8,0 C3.581722,8.11624501e-16 -5.41083001e-16,3.581722 0,8 L0,64 C5.41083001e-16,68.418278 3.581722,72 8,72 Z" fill="#007EBB"/><path d="M62,62 L51.315625,62 L51.315625,43.8021149 C51.315625,38.8127542 49.4197917,36.0245323 45.4707031,36.0245323 C41.1746094,36.0245323 38.9300781,38.9261103 38.9300781,43.8021149 L38.9300781,62 L28.6333333,62 L28.6333333,27.3333333 L38.9300781,27.3333333 L38.9300781,32.0029283 C38.9300781,32.0029283 42.0260417,26.2742151 49.3825521,26.2742151 C56.7356771,26.2742151 62,30.7644705 62,40.051212 L62,62 Z M16.349349,22.7940133 C12.8420573,22.7940133 10,19.9296567 10,16.3970067 C10,12.8643566 12.8420573,10 16.349349,10 C19.8566406,10 22.6970052,12.8643566 22.6970052,16.3970067 C22.6970052,19.9296567 19.8566406,22.7940133 16.349349,22.7940133 Z M11.0325521,62 L21.769401,62 L21.769401,27.3333333 L11.0325521,27.3333333 L11.0325521,62 Z" fill="#FFF"/></g>
        </svg>
      </a>
      <a href="https://speakerdeck.com/janko_m" title="Speaker Deck" target="_blank">
        <svg class="w-5 h-5 xs:w-6 xs:h-6 sm:w-7 sm:h-7 transition hover:scale-[1.2] duration-200 ease-in ease-out" viewBox="0 0 256 160">
          <g><path d="M106.932331,100 L50,100 C22.3857624,100 0,77.6142376 0,50 C0,22.3857624 22.3857624,0 50,0 L116.421053,0 C127.466748,0 136.421053,8.9543048 136.421053,20 C136.421053,31.0456952 127.466748,40 116.421053,40 L48.977444,40 C43.454596,40 38.977444,44.4771528 38.977444,50 C38.977444,55.5228472 43.454596,60 48.977444,60 L105.909774,60 C133.524012,60 155.909774,82.3857624 155.909774,110 C155.909774,137.614238 133.524012,160 105.909774,160 L20,160 C8.9543048,160 0,151.045695 0,140 C0,128.954305 8.9543048,120 20,120 L106.932331,120 C112.455178,120 116.932331,115.522847 116.932331,110 C116.932331,104.477153 112.455178,100 106.932331,100 Z M149.013633,160 C162.31303,151.005667 171.818454,136.66797 174.567639,120 L206.843433,120 C212.273117,120 216.674746,115.522847 216.674746,110 L216.674746,50 C216.674746,44.4771528 212.273117,40 206.843433,40 L148.210526,40 C152.880793,34.6924352 155.720602,27.683544 155.720602,20 C155.720602,12.316456 152.880793,5.3075648 148.210526,0 L216.674746,0 C238.393484,0 256,17.9086104 256,40 L256,120 C256,142.09139 238.393484,160 216.674746,160 L149.013633,160 Z" fill="#009287"></path></g>
        </svg>
      </a>
      <a href="mailto:janko@hey.com" title="Email">
        <svg class="w-5 h-5 xs:w-6 xs:h-6 sm:w-7 sm:h-7 transition hover:scale-[1.2] duration-200 ease-in ease-out text-red-500" viewBox="0 0 20 20" fill="currentColor">
          <path d="M1.574 5.286c0.488 0.262 7.248 3.894 7.5 4.029s0.578 0.199 0.906 0.199c0.328 0 0.654-0.064 0.906-0.199s7.012-3.767 7.5-4.029c0.489-0.263 0.951-1.286 0.054-1.286h-16.919c-0.897 0-0.435 1.023 0.053 1.286zM18.613 7.489c-0.555 0.289-7.387 3.849-7.727 4.027s-0.578 0.199-0.906 0.199-0.566-0.021-0.906-0.199-7.133-3.739-7.688-4.028c-0.39-0.204-0.386 0.035-0.386 0.219s0 7.293 0 7.293c0 0.42 0.566 1 1 1h16c0.434 0 1-0.58 1-1 0 0 0-7.108 0-7.292s0.004-0.423-0.387-0.219z"></path>
        </svg>
      </a>
    </div>
  </div>
</div>

</div>

<div class="mt-8 md:mt-10">
  
  <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'twinblog'; // required: replace example with your forum shortname
    var disqus_identifier = '/building-sql-expressions-with-sequel';
    var disqus_url = 'https://janko.io/building-sql-expressions-with-sequel/';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>



</div>

      </main>
    </div>

    <div class="border-t py-7 mt-10 bg-gray-50 dark:bg-slate-950 dark:border-slate-700">
      <footer class="max-w-screen-sm md:max-w-screen-md mx-auto flex flex-col space-y-2 md:flex-row md:justify-between md:space-y-0 text-base">
        <ul class="inline-flex space-x-4 font-medium justify-center md:justify-left">
          <li><a class="transition hover:text-pink-600" href="/">Articles</a></li>
          <li><a class="transition hover:text-pink-600" href="https://github.com/janko/janko.io">Source code</a></li>
        </ul>
        <p class="text-slate-500 text-center md:text-left">
          © 2023 Janko Marohnić. All rights reserved.
        </p>
      </footer>
    </div>

    <script>
      function toggleClass(element, classNames, force) {
        classNames.split(' ').forEach(function(className) {
          element.classList.toggle(className, force)
        })
      }

      const btnToggle = document.querySelector('.theme-toggle')
      const btnReset = document.querySelector('.theme-reset')

      function syncTheme() {
        const enabled = document.documentElement.classList.contains('dark')

        const ring = btnToggle.querySelector('.theme-toggle-ring')
        const light = btnToggle.querySelector('.theme-toggle-light')
        const dark = btnToggle.querySelector('.theme-toggle-dark')

        toggleClass(btnToggle, 'bg-pink-500', enabled)
        toggleClass(btnToggle, 'bg-slate-200', !enabled)

        toggleClass(ring, 'translate-x-5', enabled)
        toggleClass(ring, 'translate-x-0', !enabled)

        toggleClass(light, 'opacity-0 duration-100 ease-out', enabled)
        toggleClass(light, 'opacity-100 duration-200 ease-in', !enabled)

        toggleClass(dark, 'opacity-100 duration-200 ease-in', enabled)
        toggleClass(dark, 'opacity-0 duration-100 ease-out', !enabled)
      }

      btnToggle.addEventListener('click', function() {
        const enabled = document.documentElement.classList.toggle('dark')

        localStorage.theme = enabled ? 'dark' : 'light'

        syncTheme()

        btnReset.classList.remove('hidden')
      })

      btnReset.addEventListener('click', function() {
        localStorage.removeItem('theme')

        updateTheme()
        syncTheme()

        btnReset.classList.add('hidden')
      })

      syncTheme()
      btnReset.classList.toggle('hidden', !('theme' in localStorage))
    </script>
  </body>
</html>
